{
    "S1217": {
        "name": "\"Thread.run()\" should not be called directly",
        "desc": "This rule raises an issue when Thread.run() is called instead of Thread.start().\nWhy is this an issue?\nThe likely intention of a user calling Thread.run() is to start the execution of code within a new thread. This, however, is not what\nhappens when this method is called.\nThe purpose of Thread.run() is to provide a method that users can overwrite to specify the code to be executed. The actual thread is\nthen started by calling Thread.start(). When Thread.run() is called directly, it will be executed as a regular method within\nthe current thread.\nHow to fix it\nIf you intend to execute the contents of the Thread.run() method within a new thread, call Thread.start() instead.\nIf your intention is only to have a container for a method but execute this method within the current thread, do not use Thread but\nRunnable or another functional interface.",
        "folder_name": "S1217",
        "contextual": false,
        "ruleset": "SonarQube"
    },
    "S1860": {
        "name": "Synchronization should not be done on instances of value-based classes",
        "desc": "Why is this an issue?\nInstances of value-based classes, which are pooled and potentially reused, should not be used for synchronization. If they are, it can cause\nunrelated threads to deadlock with unhelpful stacktraces.\nWithin the JDK, types which should not be used for synchronization include:\n\n String literals \n Primitive wrapper classes in java.lang (such as Boolean with Boolean.FALSE and\n  Boolean.TRUE) \n The class java.lang.Runtime.Version \n The Optional* classes in java.util: Optional, OptionalInt, OptionalLong, and\n  OptionalDouble \n Various classes in the java.time API: Instant, LocalDate, LocalTime,\n  LocalDateTime, ZonedDateTime, ZoneId, OffsetTime, OffsetDateTime,\n  ZoneOffset, Duration, Period, Year, YearMonth, and MonthDay \n Various classes in the java.time.chrono API: MinguoDate, HijrahDate, JapaneseDate, and\n  ThaiBuddhistDate \n The interface java.lang.ProcessHandle and its implementation classes \n The implementation classes of the collection factories in java.util: List.of, List.copyOf,\n  Set.of, Set.copyOf, Map.of, Map.copyOf, Map.ofEntries, and Map.entry.\n  \n\nHow to fix it\nReplace instances of value-based classes with a new object instance to synchronize on.",
        "folder_name": "S1860",
        "contextual": false,
        "ruleset": "SonarQube"
    },
    "S2095": {
        "name": "Resources should be closed",
        "desc": "Why is this an issue?\nConnections, streams, files, and other classes that implement the Closeable interface or its super-interface,\nAutoCloseable, needs to be closed after use. Further, that close call must be made in a finally block otherwise\nan exception could keep the call from being made. Preferably, when class implements AutoCloseable, resource should be created using\n\"try-with-resources\" pattern and will be closed automatically.\nFailure to properly close resources will result in a resource leak which could bring first the application and then perhaps the box the application\nis on to their knees.\nNoncompliant code example\n\nprivate void readTheFile() throws IOException {\n  Path path = Paths.get(this.fileName);\n  BufferedReader reader = Files.newBufferedReader(path, this.charset);\n  // ...\n  reader.close();  // Noncompliant\n  // ...\n  Files.lines(\"input.txt\").forEach(System.out::println); // Noncompliant: The stream needs to be closed\n}\n\nprivate void doSomething() {\n  OutputStream stream = null;\n  try {\n    for (String property : propertyList) {\n      stream = new FileOutputStream(\"myfile.txt\");  // Noncompliant\n      // ...\n    }\n  } catch (Exception e) {\n    // ...\n  } finally {\n    stream.close();  // Multiple streams were opened. Only the last is closed.\n  }\n}\n\nCompliant solution\n\nprivate void readTheFile(String fileName) throws IOException {\n    Path path = Paths.get(fileName);\n    try (BufferedReader reader = Files.newBufferedReader(path, StandardCharsets.UTF_8)) {\n      reader.readLine();\n      // ...\n    }\n    // ..\n    try (Stream<String> input = Files.lines(\"input.txt\"))  {\n      input.forEach(System.out::println);\n    }\n}\n\nprivate void doSomething() {\n  OutputStream stream = null;\n  try {\n    stream = new FileOutputStream(\"myfile.txt\");\n    for (String property : propertyList) {\n      // ...\n    }\n  } catch (Exception e) {\n    // ...\n  } finally {\n    stream.close();\n  }\n}\n\nExceptions\nInstances of the following classes are ignored by this rule because close has no effect:\n\n java.io.ByteArrayOutputStream \n java.io.ByteArrayInputStream \n java.io.CharArrayReader \n java.io.CharArrayWriter \n java.io.StringReader \n java.io.StringWriter \n\nJava 7 introduced the try-with-resources statement, which implicitly closes Closeables. All resources opened in a try-with-resources\nstatement are ignored by this rule.\n\ntry (BufferedReader br = new BufferedReader(new FileReader(fileName))) {\n  //...\n}\ncatch ( ... ) {\n  //...\n}\n\nResources\n\n MITRE, CWE-459 - Incomplete Cleanup \n MITRE, CWE-772 - Missing Release of Resource after Effective Lifetime \n CERT, FIO04-J. - Release resources when they are no longer needed \n CERT, FIO42-C. - Close files when they are no longer needed \n Try With Resources ",
        "folder_name": "S2095",
        "contextual": false,
        "ruleset": "SonarQube"
    },
    "S2111": {
        "name": "\"BigDecimal(double)\" should not be used",
        "desc": "Why is this an issue?\nThe BigDecimal is used to represents immutable, arbitrary-precision signed decimal numbers.\nDifferently from the BigDecimal, the double primitive type and the Double type have limited precision due to\nthe use of double-precision 64-bit IEEE 754 floating point. Because of floating point imprecision, the BigDecimal(double) constructor can\nbe somewhat unpredictable.\nFor example writing new BigDecimal(0.1) doesn\u2019t create a BigDecimal which is exactly equal to 0.1, but it is equal to\n0.1000000000000000055511151231257827021181583404541015625. This is because 0.1 cannot be represented exactly as a double (or, for that matter, as a\nbinary fraction of any finite length).\nHow to fix it\nUse BigDecimal.valueOf, which uses a string under the covers to eliminate floating point rounding errors, or the constructor that\ntakes a String argument.",
        "folder_name": "S2111",
        "contextual": false,
        "ruleset": "SonarQube"
    },
    "S2116": {
        "name": "\"hashCode\" and \"toString\" should not be called on array instances",
        "desc": "Why is this an issue?\nThe purpose of the hashCode method is to return a hash code based on the contents of the object. Similarly, the purpose of the\ntoString method is to provide a textual representation of the object\u2019s contents.\nCalling hashCode() and toString() directly on array instances should be avoided because the default implementations\nprovided by the Object class do not provide meaningful results for arrays. hashCode() returns the array\u2019s \"identity hash\ncode\", and toString() returns nearly the same value. Neither method\u2019s output reflects the array\u2019s contents.\nHow to fix it\nUse relevant static Arrays method.\n\n Arrays.hashCode or Arrays.deepHashCode \n Arrays.toString or Arrays.deepToString \n",
        "folder_name": "S2116",
        "contextual": false,
        "ruleset": "SonarQube"
    },
    "S2142": {
        "name": "\"InterruptedException\" and \"ThreadDeath\" should not be ignored",
        "desc": "Why is this an issue?\nIf an InterruptedException or a ThreadDeath error is not handled properly, the information that the thread was\ninterrupted will be lost. Handling this exception means either to re-throw it or manually re-interrupt the current thread by calling\nThread.interrupt(). Simply logging the exception is not sufficient and counts as ignoring it. Between the moment the exception is caught\nand handled, is the right time to perform cleanup operations on the method\u2019s state, if needed.\nWhat is the potential impact?\nFailing to interrupt the thread (or to re-throw) risks delaying the thread shutdown and losing the information that the thread was interrupted -\nprobably without finishing its task.\nNoncompliant code example\n\npublic void run () {\n  try {\n    /*...*/\n  } catch (InterruptedException e) { // Noncompliant; logging is not enough\n    LOGGER.log(Level.WARN, \"Interrupted!\", e);\n  }\n}\n\nCompliant solution\n\npublic void run () {\n  try {\n    /* ... */\n  } catch (InterruptedException e) { // Compliant; the interrupted state is restored\n    LOGGER.log(Level.WARN, \"Interrupted!\", e);\n    /* Clean up whatever needs to be handled before interrupting  */\n    Thread.currentThread().interrupt();\n  }\n}\n\npublic void run () {\n  try {\n    /* ... */\n  } catch (ThreadDeath e) { // Compliant; the error is being re-thrown\n    LOGGER.log(Level.WARN, \"Interrupted!\", e);\n    /* Clean up whatever needs to be handled before re-throwing  */\n    throw e;\n  }\n}\n\nResources\n\n MITRE, CWE-391 - Unchecked Error Condition ",
        "folder_name": "S2142",
        "contextual": false,
        "ruleset": "SonarQube"
    },
    "S2184": {
        "name": "Math operands should be cast before assignment",
        "desc": "Why is this an issue?\nWhen arithmetic is performed on integers, the result will always be an integer. You can assign that result to a long,\ndouble, or float with automatic type conversion, but having started as an int or long, the result\nwill likely not be what you expect.\nFor instance, if the result of int division is assigned to a floating-point variable, precision will have been lost before the\nassignment. Likewise, if the result of multiplication is assigned to a long, it may have already overflowed before the assignment.\nIn either case, the result will not be what was expected. Instead, at least one operand should be cast or promoted to the final type before the\noperation takes place.\nNoncompliant code example\n\nfloat twoThirds = 2/3; // Noncompliant; int division. Yields 0.0\nlong millisInYear = 1_000*3_600*24*365; // Noncompliant; int multiplication. Yields 1471228928\nlong bigNum = Integer.MAX_VALUE + 2; // Noncompliant. Yields -2147483647\nlong bigNegNum =  Integer.MIN_VALUE-1; //Noncompliant, gives a positive result instead of a negative one.\nDate myDate = new Date(seconds * 1_000); //Noncompliant, won't produce the expected result if seconds > 2_147_483\n...\npublic long compute(int factor){\n  return factor * 10_000;  //Noncompliant, won't produce the expected result if factor > 214_748\n}\n\npublic float compute2(long factor){\n  return factor / 123;  //Noncompliant, will be rounded to closest long integer\n}\n\nCompliant solution\n\nfloat twoThirds = 2f/3; // 2 promoted to float. Yields 0.6666667\nlong millisInYear = 1_000L*3_600*24*365; // 1000 promoted to long. Yields 31_536_000_000\nlong bigNum = Integer.MAX_VALUE + 2L; // 2 promoted to long. Yields 2_147_483_649\nlong bigNegNum =  Integer.MIN_VALUE-1L; // Yields -2_147_483_649\nDate myDate = new Date(seconds * 1_000L);\n...\npublic long compute(int factor){\n  return factor * 10_000L;\n}\n\npublic float compute2(long factor){\n  return factor / 123f;\n}\n\nor\n\nfloat twoThirds = (float)2/3; // 2 cast to float\nlong millisInYear = (long)1_000*3_600*24*365; // 1_000 cast to long\nlong bigNum = (long)Integer.MAX_VALUE + 2;\nlong bigNegNum =  (long)Integer.MIN_VALUE-1;\nDate myDate = new Date((long)seconds * 1_000);\n...\npublic long compute(long factor){\n  return factor * 10_000;\n}\n\npublic float compute2(float factor){\n  return factor / 123;\n}\n\nResources\n\n MITRE, CWE-190 - Integer Overflow or Wraparound \n CERT, NUM50-J. - Convert integers to floating point for floating-point operations\n  \n CERT, INT18-C. - Evaluate integer expressions in a larger size before comparing or\n  assigning to that size \n SANS Top 25 - Risky Resource Management ",
        "folder_name": "S2184",
        "contextual": false,
        "ruleset": "SonarQube"
    },
    "S2225": {
        "name": "\"toString()\" and \"clone()\" methods should not return null",
        "desc": "Why is this an issue?\nCalling toString() or clone() on an object should always return a string or an object. Returning null\ninstead contravenes the method\u2019s implicit contract.\nNoncompliant code example\n\npublic String toString () {\n  if (this.collection.isEmpty()) {\n    return null; // Noncompliant\n  } else {\n    // ...\n\nCompliant solution\n\npublic String toString () {\n  if (this.collection.isEmpty()) {\n    return \"\";\n  } else {\n    // ...\n\nResources\n\n MITRE, CWE-476 - NULL Pointer Dereference \n CERT, EXP01-J. - Do not use a null in a case where an object is required ",
        "folder_name": "S2225",
        "contextual": false,
        "ruleset": "SonarQube"
    },
    "S2272": {
        "name": "\"Iterator.next()\" methods should throw \"NoSuchElementException\"",
        "desc": "Why is this an issue?\nThe java.util.Iterator.next() method must throw a NoSuchElementException when there are no more elements in the\niteration. Any other behavior is non-compliant with the API contract and may cause unexpected behavior for users.\nNoncompliant code example\n\npublic class MyIterator implements Iterator<String> {\n  public String next() {\n    if (!hasNext()) {\n      return null;\n    }\n    // ...\n  }\n}\n\nCompliant solution\n\npublic class MyIterator implements Iterator<String> {\n  public String next() {\n    if (!hasNext()) {\n      throw new NoSuchElementException();\n    }\n    // ...\n  }\n}\n\nResources\nDocumentation\n\n Java SE 7 API Specification: Iterator ",
        "folder_name": "S2272",
        "contextual": false,
        "ruleset": "SonarQube"
    },
    "S4973": {
        "name": "Strings and Boxed types should be compared using \"equals()\"",
        "desc": "Why is this an issue?\nIt\u2019s almost always a mistake to compare two instances of java.lang.String or boxed types like java.lang.Integer using\nreference equality == or !=, because it is not comparing actual value but locations in memory.\nNoncompliant code example\n\nString firstName = getFirstName(); // String overrides equals\nString lastName = getLastName();\n\nif (firstName == lastName) { ... }; // Non-compliant; false even if the strings have the same value\n\nCompliant solution\n\nString firstName = getFirstName();\nString lastName = getLastName();\n\nif (firstName != null && firstName.equals(lastName)) { ... };\n\nResources\n\n MITRE, CWE-595 - Comparison of Object References Instead of Object Contents \n MITRE, CWE-597 - Use of Wrong Operator in String Comparison \n CERT, EXP03-J. - Do not use the equality operators when comparing values of boxed\n  primitives \n CERT, EXP50-J. - Do not confuse abstract object equality with reference equality\n  ",
        "folder_name": "S4973",
        "contextual": false,
        "ruleset": "SonarQube"
    }
}